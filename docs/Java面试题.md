# 面试题
##·final, finally, finalize三者的区别:

	·final
		表示不可变的，用来修饰类、方法和变量。
	 	
	 	当它修饰类的时候表示该类是不可被继承的，因为抽象类就是被继承的，所以abstract关键字和final关键字不能共存。
	 	
	 	当它修饰方法的时候表示该方法是不能被重写的。
	 	
	 	当它修饰变量的时候表示该变量的值不能发生变化，对于用final修饰的变量我们必须在申明它的时候赋值或者在构造函数中给它赋值。
	·finally
	 	是异常处理中的一个关键字，通常用于try-catch-finally结构。

	 	它一般用于资源释放，例如关闭数据库的连接、输入输出流的关闭，在finally结构中的代码不管有没有异常发生都会执行。

	 	但是finally中的代码不是总会被执行的，在以下情况中不会执行finally中的代码：
	 		·1.在进入try模块之前程序发生了异常
	 		·2.在try模块中调用了System.exit(0)终止了JVM的运行。
	 		·3.在try模块或catch模块中程序被中断，比如死机。

	 	finally运行顺序:
	 		·1.finally在try模块和catch模块内的return执行后，返回前执行。
	 		·2.如果finally中没有return，则其执行结果不会影响try模块和catch模块中已确定的返回值。
	 		·3.如果finally中有return，则执行结果会直接返回。
	·finalize
		是Object类的一个方法，因为所有的类都继承自Object类，所以所有的类都有finalize方法。

		在垃圾收集器将该对象清除出内存之前都会先调用它的finalize方法，做一些内存清理工作，通常这部分内存是非Java内存，如Socket，finalize只会被调用一次。

##synchronized与lock的异同？

	·相同点: 二者都可以解决线程的安全问题
	·不同点: synchronized机制在执行完相应的同步代码后，自动的释放同步监视器
		Lock需要手动的启动同步(lock()), 同时结束同步也需要手动实现(unlock())

##如何解决线程安全问题？有哪几种方式

	·1.同步代码块
	·2.同步方法
	·3.Lock锁

##sleep()和wait()方法的异同

	·相同点: 一旦执行，都可以使得当前的线程进入阻塞状态
	·不同点: 
		·1.两个方法声明的位置不同
		·2.两个方法的调用要求不同: sleep()可以在任何需要的场景调用，wait()必须在同步代码块或同步方法中调用
		·3.关于是否释放同步监视器: 如果两个方法都使用在同步代码块或同步方法中时，sleep()不会释放同步监视器，wait()会释放同步监视器

##如何理解Callable接口创建线程比Runnable接口强大？

	·1.call()方法可以有返回值的
	·2.call()可以抛出异常，被外面的操作捕获，获取异常的信息
	·3.Callable是支持泛型的

##创建多线程有几种方式？

	·四种:
		·方式1: 继承于Thread类
		·方式2: 实现Runnable接口
		·方式3: 实现Callable接口 ————JDK 5.0新增
		·方式4: 使用线程池

##String s = new String("abc")创建对象，在内存中共创建了几个对象？

	·两个: 一个是堆空间中new结构，另一个是char[]对应的常量池中的数据:"abc"

## Arraylist Linkedlist Vector 三者的异同？

	·相同点: 三个类都是实现了list接口，存储数据的特点相同: 存储有序的可重复的数据
	·不同点: 
		·Vector: 作为List接口的古老实现类，线程安全的，效率低，底层用Object[] elementData存储
		·Linkedlist: 对频繁的插入删除操作，使用效率比Arraylist高，底层使用双向链表存储
		·Arraylist: 作为list接口的主要实现类，线程不安全，效率高，底层使用Object[] elementData存储

## HashMap的底层实现原理
	
	·JDK7中	
		·在实例化以后，底层创建了长度是16的一维数组Entry[] table 
		·put操作时，首先调用key所在类的hashcode()计算key的哈希值,此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置，如果次位置上的数据为空，此时的key-value添加成功，否则，如果key的哈希值与该位置上的数据都不同，以链表形式添加到该位置，若相同则替换该位置上的相同数据
		·在不断的添加过程中会涉及扩容问题，默认扩容方式: 
		扩容为原来容量的两倍，并将原有的数据赋值过来
	·JDK8中
		·实例化时底层不会创建一个长度为16的数组
		·JDK8中底层数组为node[]
		·首次调用put()方法时才会创建长度为16的数组
		·JDK7中底层结构只有: 数组+链表，JDK8中底层结构为数组+链表+红黑树
		·当数组的某一个索引位置上的元素以链表形式存在的数据 > 8且当前数组的长度 > 64时，此时索引位置上的所有数据改为使用红黑树存储

## HashMap和Hashtable的异同

	·

## currentHashMap与Hashtable的异同