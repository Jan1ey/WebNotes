# 线程
## 基本概念: 程序、进程、线程

	·程序(program): 为完成特定任务、用某种语言编写的一组指令集合。即指一段静态的代码，静态对象
	·进程(process): 是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程: 有它自身的产生、存在和消亡的过程。————生命周期
		   进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域
    ·线程(thread): 是一个程序内部的一条执行路径.
    		若一个进程同一时间并行执行多个线程，就是支持多线程的
    		线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)，线程切换的开销小
    		一个进程中的多个线程共享相同的内存单元、内存地址空间->它们从同一个堆中分配对象，可以访问相同的变量和对象。这就使得线程间的通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全隐患.
    ·一个Java应用程序Java.exe，至少有三个线程: main()主线程，gc()垃圾回收线程，异常处理线程.
    ·并行: 多个CPU同时执行多个任务.
    ·并发: 一个CPU(采用时间片)同时执行多个任务.

## 多线程的优点

	·提高应用程序的响应。对图形化界面更有意义，可增强用户体验
	·提高计算机系统CPU的利用率
	·改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改

## 多线程的应用场景

	·程序需要同时执行两个或多个任务
	·程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等
	·需要一些后台运行的程序时

## 多线程的创建和使用
	
	·方式1: 继承于Thread类
		·1.创建一个继承于Thread类的子类
		·2.重写Thread类的run()
		·3.创建Thread类的子类的对象
		·4.通过此对象调用start()
	·方式2: 实现Runnable接口
		·1.创建一个实现了Runnable接口的类
		·2.实现类去实现Runnable中的抽象方法: run()
		·3.创建类的操作对象
		·4.将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象
		·5.通过Thread类的对象调用start()	
	·方式3: 实现Callable接口 ————JDK 5.0新增
		·1.创建一个实现了Callable接口的类
		·2.实现类去实现Callable中的抽象方法: call()
		·3.创建实现类的操作对象
		·4.将此对象作为参数传递到FutureTask类的构造器中，创建FutureTask
		·5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()方法
	·方式4: 使用线程池
		·提前创建好多个线程，放入线程池中，使用时直接获取，是用完放回池中。可以避免频繁创建销毁、实现重复利用
		·提高了响应速度，降低资源消耗，便于线程管理

## Thread类常用方法

	·Start(): 启动当前线程，调用当前线程的run();
	·run(): 通常需要重写Thread类中的该方法，将创建的线程要执行的代码声明在此方法中
	·currentThread(): 静态方法，返回执行当前代码的线程
	·getName(): 获取当前线程的名字
	·setName(): 设置当前线程的名字
	·yield(): 释放当前CPU的执行权
	·join(): 在线程a中调用线程b的join()，此时线程a就进入阻塞状态，直到线程b完全执行完成以后，线程a才结束阻塞状态
	·sleep(long millitime): 让当前线程“睡眠”指定的millitime秒，在指定的时间内，当前线程是阻塞状态
	·isAlive(): 判断当前线程是否存活

## 线程的优先级

	·优先级参数: MAX_PRIORITY: 10, MIN_PRIORITY: 1, NORM_PRIORITY: 5;
	·getPriority(): 获取线程的优先级
	·setPriority(int p): 设置线程的优先级
	·说明: 高优先级的线程要抢占低优先级线程的CPU执行权，但是只是从概率上讲，高优先级的线程高概率被执行，并不意味着只有高优先级的线程执行完以后，低优先级的线程才执行

## 创建线程的两种方式的比较

	·Thread类也实现了Runnable接口，不管是继承还是实现，都需要重写run()
	·开发中优先选择实现Runnable接口的方式:
		原因: 1.实现的方式没有类的单继承性的局限性
		      2.实现的方式更适合来处理多个线程有共享数据的情况

## 线程的同步

	·方式一: 同步代码块
		·synchronized(同步监视器) {
			//需要被同步的代码(操作共享数据的代码即为需要被同步的代码)

		}
		·同步监视器: 俗称锁，任何一个类的对象，都可以充当锁。
			要求: 多个线程必须共同一个锁
	·方式二: 同步方法
		·在方法名声明中加入synchronized
		·同步方法仍然涉及到同步监视器，只是不需要我们显示的声明
		·非静态的同步方法，同步监视器是this
		·静态的同步方法，同步监视器是当前类本身 
	·方法三: Lock锁
		·

## 线程的死锁

	·不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了死锁

## 线程的通信

	·wait(): 一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器
	·notify(): 一旦执行此方法，就会唤醒被wait的一个线程，如果有多个线程被wait，就唤醒优先级高的线程
	·notifyAll(): 一旦执行此方法，就会唤醒所有被wait的线程
	·以上三个方法定义在Object类中，必须使用在同步代码块或者同步方法中，调用者必须是同步代码块或同步方法中的同步监视器，否则会出现IllegalMonitorStateException异常