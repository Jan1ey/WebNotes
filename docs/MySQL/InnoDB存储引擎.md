# InnoDB 存储引擎

* InnoDB 是默认的表存储引擎。其特点是行锁设计、支持 MVCC 、支持外键、提供一致性非锁定读、同时被设计用来最有效的利用以及使用内存和 CPU 。
***

## 一、 InnoDB体系架构

* InnoDB 体系结构由后台线程、内存池、文件构成。

### 1.1 后台线程

* InnoDB 后台线程主要有四种不同类型的线程：

>- 1.Master Thread：最核心的一个线程，负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性。

>- 2.IO Thread： InnoDB 存储引擎使用大量的异步 IO 处理 IO 请求，IO Trhead 负责这些 IO 的请求回调处理。

>- 3.Purge Thread：Purge Thread 用来回收已经使用并分配的 undo 页。InnoDB 支持多个 Purge Thread，可以加快 undo 页的回收。

>- 4.Page Cleaner Thread： 在InnoDB 1.2.x版本新引入，作用是将之前版本中脏页的刷新操作都放入到单独的线程中来完成，减轻了 Master Thread 的工作以及对于用户查询线程的阻塞。
***

### 1.2 内存

* InnoDB 使用缓冲池技术来提高数据库的整体性能。

> 缓冲池简单的说是一块内存区域，数据库中进行的读取页操作，会将从磁盘中读取到的页存放到缓冲池中，下一次读取该页时，会先判断该页是否在内存池中，如果在，就直接在缓冲池中读取。对于数据库中修改页的操作，会先修改缓冲池中的页，然后以一定频率刷新到磁盘，并不是每次页发生变化就刷新到磁盘。

* 在 InnoDB 中，缓冲池中的页大小默认为 16 KB。

> 缓冲池中缓存的数据页类型有：索引页、数据页、undo 页、插入缓冲、自适应哈希索引、InnoDB 的锁信息、数据字典信息等。

* InnoDB 存储引擎通过 Free 链表（空闲链表）管理缓冲池中的缓存页。

> 每次从磁盘中加载一个页到缓冲池中时，就从 Free 链表中取一个空闲的缓存页节点，将加载的页的信息填入对应的空闲缓存页信息中并从链表移除该节点

* 缓冲池最主要的两个功能：

>- 加速读：当需要访问一个页面时，如果这个页面已经在缓冲池中，直接从缓冲池中获取这个页面。

>- 加速写：当需要修改一个页面时，如果这个页面已经在缓冲池中，直接从缓冲池中修改这个页面。

* InnoDB Buffer Pool 采用经典的 LRU（Least Recently Used） 算法来进行页面淘汰，以提高缓存命中率。

>- 创建一个 LRU 链表，当需要访问某个页时，如果该页不在缓冲池中，就从磁盘中将该页加载到缓冲池中，并包装成节点添加到 LRU 链表的头部；如果该页已经在缓冲池中，就直接把该页对应的节点移动到 LRU 链表头部。

>- InnoDB 存储引擎对传统 LRU 算法做了一些优化，在 InnoDB 中加入了 midpoint。当一个新的页被加载到缓冲中时，不会直接将该页添加到 LRU 链表的首部，而是将其插入 LRU 链表的 midpoint 位置, midpoint 位置之前的页为热点数据。这个算法称为 midpoint insertion stategy。默认的 midpoint 位置为链表长度的 5/8 处，可以通过 innodb_old_blocks_pct 参数控制 midpoint 位置。

* 缓冲池中需要更新的缓存页称为脏页（dirty page），为了管理脏页刷新到磁盘的时间和顺序，缓冲池中创建了 FLUSH 链表。

>- FLUSH 链表中存储的是在 LRU 链表中被修改过的页，只有第一次被修改时缓存页才会被添加进 FLUSH 链表。FLUSH 链表中存放的脏页是通过指针指向 LRU 链表中的脏页，脏页的实际数据还是存储在 LRU 链表中。FLUSH 链表中的脏页是根据 oldest_lsn 值进行排序刷新到磁盘中。

## 二、CheckPoint 技术

* 2.1 CheckPoint 技术是用来解决如下几个问题：

> 1.缩短数据库恢复时间
> >- 重做日志中记录了 CheckPoint 的位置，在 CheckPoint 之前的缓存页已经刷新回到磁盘中，只需要对 CheckPoint 之后的重做日志进行恢复，大大缩短了恢复时间。

> 2.缓冲池不够用时，将脏页刷新到磁盘
> >- 当缓冲池不够用时，根据 LRU 算法，溢出最近最少使用的页，如果该页为脏页，强制执行 CheckPoint，将脏页刷新回到磁盘。

> 3.重做日志不可用时，刷新脏页
> >- 数据库恢复时，如果不需要重复日志的情况下，重复日志可以被覆盖；如果需要的话，重做日志就是不可被覆盖的，必须强制执行 CheckPoint，将缓冲池中的页至少刷新到当前重做日志的位置。

* 2.2 CheckPoint 在 InnoDB 存储引擎内部有两种类型

> Sharp CheckPoint 
> >- Sharp CheckPoint 发生在数据库关闭时，将所有脏页刷新回磁盘，但是不适用于数据库运行时的刷新。

> Fuzzy CheckPoint 
> >- 在数据库运行时，InnoDB 存储引擎内部采用 Fuzzy CheckPoint，只刷新一部分脏页。

## 三、InnoDB 关键特性

* 3.1 插入缓冲

> 对于非聚集索引的插入和更新操作，不是每一次直接插入到索引页中，而是先判断插入非聚集索引页是否在缓冲池中，若存在，则直接插入，否则会先在缓冲池中放入一个 Insert Buffer 对象，这时实际上数据库中这个非聚集的索引并没有插到页的子节点，只是存放在另外一个位置。然后以一定的频率根据情况进行 Insert Buffer 和辅助索引页子节点的 Merge 操作，这是通常能将多个插入合并到一个操作中，大大提高了对于非聚集索引插入的性能。
> Insert Buffer 需要满足的两个条件是：
> >- 索引是辅助索引
> >- 索引不是唯一的

* 3.2 两次写

> 部分写失效问题：当数据库正在从内存中向磁盘写一个数据页时，数据库宕机，从而导致这个页只写入了部分数据，会导致数据丢失，这就是部分写失效。

> 两次写：

> >- 两次写需要额外添加两个部分：
> > >- 1.内存中的两次写缓冲（doublewrite buffer），大小为 2 MB 
> > >- 2.磁盘上共享表空间中连续的128页，大小也为 2 MB

> >- 两次写的原理：
> > >- 1.当刷新缓冲池脏页时，并不直接写到数据文件中，而是先拷贝至内存中的两次写缓冲区。
> > >- 2.然后从两次写缓冲区分两次写入磁盘共享表空间中，每次写入 1 MB。
> > >- 3.等待第二步完成后，再将两次写缓冲区写入数据文件。

> 在遇到部分写失效问题时，因为在磁盘共享空间中已有数据页副本拷贝，在实例恢复时，可以从共享表空间中找到该页副本，将其拷贝覆盖原有数据页，再应用重做日志即可。

> 可以通过参数 skip_innodb_doublewrite 禁用两次写功能，默认是开启的。

* 3.3 自适应哈希索引

> InnoDB 存储引擎会监控对表上各索引页的查询，如果观察到建立哈希索引可以提升速度，则建立哈希索引，称之为自适应哈希索引（Adaptive Hash Index, AHI）。

> 自适应哈希索引的条件：
> >- 1.对这个页的连续访问模式（查询条件）必须一样。
> >- 2.这个页通过该模式访问了 N 次，其中 N = 页中记录条数/16。

> 启用 AHI 后，读取和写入的速度可以提高 2 倍，负责索引的链接操作性能可以提高 5 倍。

* 3.4 异步 IO（AIO）

> 用户可以在发出一个 IO 请求后立即在发出另外一个 IO 请求，当全部 IO 请求发送完毕后，等待所有 IO 操作完成，这就是 AIO。

> AIO 的另外一个优势是进行 IO Merge 操作，也就是将多个 IO 合并为一个 IO 操作，这样可以提高 IOPS 的性能。

> 在InnoDB 1.1.x 之前，AIO 的实现是通过 InnoDB 存储引擎中的代码来模拟的，但是从这之后，操作系统提供了内核级别的 AIO 支持，称为 Native AIO。Windows 和 Linux 系统均支持 Native AIO，而 Mac 系统未提供支持。

> 可以通过 innodb_use_native_aio 来决定是否启用 Native AIO。

* 3.5 刷新邻接页

> InnoDB 存储引擎在刷新一个脏页时，会检测该页所在的区（extent）的所有页，如果是脏页，那么一起刷新。这样做的好处是可以通过 AIO 将多个 IO 写操作合并为一个 IO 操作。该工作机制在机械硬盘下有显著优势。

> InnoDB 存储引擎 1.2.x 版本开始提供参数 innodb_flush_neighbors 来决定是否启用。对于传统机械硬盘建议使用，而对于固态硬盘可以关闭。 
*** 


## 参考文献

> [一文了解 InnoDB 存储引擎](https://zhuanlan.zhihu.com/p/47581960)